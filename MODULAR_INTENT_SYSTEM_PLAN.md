# üöÄ Mod√ºler Intent Sistemi ve React Widget Entegrasyonu - Kapsamlƒ± Plan

## üìã **Proje Analizi ve Mevcut Durum**

### **1. Laravel Backend (TESTAI) - Mevcut Durum:**
- ‚úÖ **Intent Detection**: GPT destekli akƒ±llƒ± intent tespiti
- ‚úÖ **Semantic Search**: Knowledge base √ºzerinde semantic arama
- ‚úÖ **Basic Intent Handling**: Switch-case ile intent bazlƒ± response generation
- ‚úÖ **API Endpoints**: `/api/chat`, `/api/feedback`, `/api/product-click`
- ‚ùå **Mod√ºler Yapƒ±**: Intent'ler hardcoded, geni≈ületilemez
- ‚ùå **Plugin Sistemi**: Yeni intent'ler eklemek i√ßin kod deƒüi≈üikliƒüi gerekli

### **2. React Widget (widget/) - Mevcut Durum:**
- ‚úÖ **Component System**: Intent bazlƒ± message component'leri
- ‚úÖ **API Integration**: Laravel API ile tam entegrasyon
- ‚úÖ **Event Handling**: Feedback, product click, cargo tracking
- ‚úÖ **Template System**: Product, Order, Cargo, Feedback template'leri
- ‚ùå **Dynamic Component Loading**: Component'ler statik import
- ‚ùå **Widget Plugin System**: Yeni widget'lar eklemek i√ßin kod deƒüi≈üikliƒüi gerekli

---

## üéØ **Hedef: Tam Mod√ºler Intent ve Widget Sistemi**

### **Ana Ama√ßlar:**
1. **Intent Plugin Sistemi**: Yeni intent'leri kod deƒüi≈üikliƒüi yapmadan ekleyebilme
2. **Widget Plugin Sistemi**: Yeni widget'larƒ± dinamik olarak y√ºkleyebilme
3. **Configuration Driven**: JSON/YAML config ile sistem y√∂netimi
4. **Hot Reload**: Intent ve widget'larƒ± runtime'da g√ºncelleyebilme
5. **Extensible Architecture**: Plugin developer'lar i√ßin kolay API

---

## üèóÔ∏è **Sistem Mimarisi**

### **1. Laravel Backend - Mod√ºler Intent Sistemi**

#### **1.1 Intent Plugin Interface**
```php
interface IntentPluginInterface
{
    public function getIntentName(): string;
    public function getIntentDescription(): string;
    public function getIntentExamples(): array;
    public function getIntentCategory(): string;
    public function getRequiredPermissions(): array;
    public function canHandle(string $query): bool;
    public function handle(string $query, array $context): IntentResponse;
    public function getWidgetConfig(): ?WidgetConfig;
    public function getRequiredData(): array;
}
```

#### **1.2 Intent Registry System**
```php
class IntentRegistry
{
    private array $plugins = [];
    
    public function register(IntentPluginInterface $plugin): void;
    public function unregister(string $intentName): void;
    public function getPlugin(string $intentName): ?IntentPluginInterface;
    public function getAllPlugins(): array;
    public function getPluginsByCategory(string $category): array;
    public function reloadPlugins(): void;
}
```

#### **1.3 Intent Plugin Base Class**
```php
abstract class BaseIntentPlugin implements IntentPluginInterface
{
    protected array $config;
    protected AIService $aiService;
    protected KnowledgeBaseService $kbService;
    
    abstract protected function processQuery(string $query, array $context): IntentResponse;
    abstract protected function getWidgetData(array $context): array;
    
    public function handle(string $query, array $context): IntentResponse
    {
        // Common logic: validation, logging, error handling
        $response = $this->processQuery($query, $context);
        $response->setWidgetConfig($this->getWidgetConfig());
        return $response;
    }
}
```

#### **1.4 Intent Response Model**
```php
class IntentResponse
{
    private string $intent;
    private float $confidence;
    private string $message;
    private array $data;
    private ?WidgetConfig $widgetConfig;
    private array $suggestions;
    private array $entities;
    private array $metadata;
    
    // Getters, setters, validation methods
}
```

#### **1.5 Widget Configuration Model**
```php
class WidgetConfig
{
    private string $widgetType;
    private string $componentName;
    private array $props;
    private array $styling;
    private array $interactions;
    private array $dataMapping;
    private array $validation;
    
    // Getters, setters, validation methods
}
```

### **2. React Widget - Mod√ºler Component Sistemi**

#### **2.1 Widget Plugin Interface**
```typescript
interface WidgetPlugin {
  id: string;
  name: string;
  version: string;
  description: string;
  author: string;
  category: string;
  component: React.ComponentType<any>;
  props: WidgetPropsSchema;
  styling: WidgetStylingSchema;
  interactions: WidgetInteractionSchema;
  dataMapping: DataMappingSchema;
}
```

#### **2.2 Widget Registry System**
```typescript
class WidgetRegistry {
  private plugins: Map<string, WidgetPlugin> = new Map();
  
  register(plugin: WidgetPlugin): void;
  unregister(pluginId: string): void;
  getPlugin(pluginId: string): WidgetPlugin | undefined;
  getAllPlugins(): WidgetPlugin[];
  getPluginsByCategory(category: string): WidgetPlugin[];
  reloadPlugins(): void;
}
```

#### **2.3 Dynamic Component Loading**
```typescript
const DynamicWidget: React.FC<{config: WidgetConfig}> = ({config}) => {
  const [Component, setComponent] = useState<React.ComponentType<any> | null>(null);
  
  useEffect(() => {
    const loadComponent = async () => {
      const plugin = widgetRegistry.getPlugin(config.widgetType);
      if (plugin) {
        setComponent(() => plugin.component);
      }
    };
    loadComponent();
  }, [config.widgetType]);
  
  if (!Component) return <WidgetLoader />;
  
  return <Component {...config.props} />;
};
```

---

## üîå **Plugin Sistemi Detaylarƒ±**

### **1. Intent Plugin √ñrnekleri**

#### **1.1 Product Search Intent Plugin**
```php
class ProductSearchIntentPlugin extends BaseIntentPlugin
{
    public function getIntentName(): string
    {
        return 'product_search';
    }
    
    public function getIntentDescription(): string
    {
        return '√úr√ºn arama ve √∂neri sistemi';
    }
    
    public function getIntentExamples(): array
    {
        return [
            'Bana g√∂re saat varmƒ±?',
            'Telefon bul',
            'Kƒ±rmƒ±zƒ± elbise ara',
            'Ne √∂nerirsin?'
        ];
    }
    
    public function getWidgetConfig(): ?WidgetConfig
    {
        return new WidgetConfig([
            'widgetType' => 'product_grid',
            'componentName' => 'ProductGridWidget',
            'props' => [
                'showFilters' => true,
                'showPagination' => true,
                'itemsPerPage' => 12
            ],
            'styling' => [
                'theme' => 'modern',
                'layout' => 'grid',
                'responsive' => true
            ]
        ]);
    }
    
    protected function processQuery(string $query, array $context): IntentResponse
    {
        // Semantic search logic
        $searchResults = $this->kbService->semanticSearch($query);
        
        return new IntentResponse([
            'intent' => 'product_search',
            'confidence' => 0.95,
            'message' => 'Size uygun √ºr√ºnleri buldum',
            'data' => $searchResults,
            'suggestions' => ['Filtrele', 'Sƒ±rala', 'Daha fazla g√∂ster']
        ]);
    }
}
```

#### **1.2 FAQ Intent Plugin**
```php
class FAQIntentPlugin extends BaseIntentPlugin
{
    public function getIntentName(): string
    {
        return 'faq_search';
    }
    
    public function getWidgetConfig(): ?WidgetConfig
    {
        return new WidgetConfig([
            'widgetType' => 'faq_accordion',
            'componentName' => 'FAQAccordionWidget',
            'props' => [
                'showSearch' => true,
                'groupByCategory' => true,
                'expandFirst' => false
            ]
        ]);
    }
    
    protected function processQuery(string $query, array $context): IntentResponse
    {
        $faqResults = $this->kbService->searchFAQ($query);
        
        return new IntentResponse([
            'intent' => 'faq_search',
            'confidence' => 0.9,
            'message' => 'Soru cevabƒ±nƒ± buldum',
            'data' => $faqResults,
            'suggestions' => ['Ba≈üka soru sor', 'ƒ∞lgili konular', 'Yardƒ±m al']
        ]);
    }
}
```

#### **1.3 Campaign Intent Plugin**
```php
class CampaignIntentPlugin extends BaseIntentPlugin
{
    public function getIntentName(): string
    {
        return 'campaign_inquiry';
    }
    
    public function getWidgetConfig(): ?WidgetConfig
    {
        return new WidgetConfig([
            'widgetType' => 'campaign_carousel',
            'componentName' => 'CampaignCarouselWidget',
            'props' => [
                'autoPlay' => true,
                'showIndicators' => true,
                'showControls' => true
            ],
            'interactions' => [
                'onCampaignClick' => 'track_campaign_click',
                'onBannerView' => 'track_banner_view'
            ]
        ]);
    }
}
```

### **2. Widget Plugin √ñrnekleri**

#### **2.1 Product Grid Widget**
```typescript
interface ProductGridWidgetProps {
  products: Product[];
  showFilters: boolean;
  showPagination: boolean;
  itemsPerPage: number;
  onProductClick: (product: Product) => void;
  onFilterChange: (filters: ProductFilters) => void;
}

const ProductGridWidget: React.FC<ProductGridWidgetProps> = ({
  products,
  showFilters,
  showPagination,
  itemsPerPage,
  onProductClick,
  onFilterChange
}) => {
  const [currentPage, setCurrentPage] = useState(1);
  const [filters, setFilters] = useState<ProductFilters>({});
  
  // Widget logic implementation
  return (
    <div className="product-grid-widget">
      {showFilters && (
        <ProductFilters 
          filters={filters}
          onChange={onFilterChange}
        />
      )}
      
      <div className="products-grid">
        {products.map(product => (
          <ProductCard
            key={product.id}
            product={product}
            onClick={() => onProductClick(product)}
          />
        ))}
      </div>
      
      {showPagination && (
        <Pagination
          currentPage={currentPage}
          totalPages={Math.ceil(products.length / itemsPerPage)}
          onPageChange={setCurrentPage}
        />
      )}
    </div>
  );
};

// Plugin registration
export const ProductGridWidgetPlugin: WidgetPlugin = {
  id: 'product_grid',
  name: 'Product Grid Widget',
  version: '1.0.0',
  description: '√úr√ºnleri grid layout ile g√∂steren widget',
  author: 'ConvStateAI Team',
  category: 'product',
  component: ProductGridWidget,
  props: {
    products: { type: 'array', required: true },
    showFilters: { type: 'boolean', default: true },
    showPagination: { type: 'boolean', default: true },
    itemsPerPage: { type: 'number', default: 12 }
  },
  styling: {
    theme: { type: 'string', enum: ['modern', 'classic', 'minimal'] },
    layout: { type: 'string', enum: ['grid', 'list', 'masonry'] }
  },
  interactions: {
    onProductClick: { type: 'function', required: true },
    onFilterChange: { type: 'function', required: false }
  }
};
```

#### **2.2 FAQ Accordion Widget**
```typescript
interface FAQAccordionWidgetProps {
  faqs: FAQ[];
  showSearch: boolean;
  groupByCategory: boolean;
  expandFirst: boolean;
  onFAQClick: (faq: FAQ) => void;
}

const FAQAccordionWidget: React.FC<FAQAccordionWidgetProps> = ({
  faqs,
  showSearch,
  groupByCategory,
  expandFirst,
  onFAQClick
}) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [expandedItems, setExpandedItems] = useState<Set<string>>(new Set());
  
  // Widget logic implementation
  return (
    <div className="faq-accordion-widget">
      {showSearch && (
        <FAQSearch
          value={searchTerm}
          onChange={setSearchTerm}
          placeholder="FAQ ara..."
        />
      )}
      
      <div className="faq-list">
        {faqs.map(faq => (
          <FAQItem
            key={faq.id}
            faq={faq}
            isExpanded={expandedItems.has(faq.id)}
            onToggle={() => toggleFAQ(faq.id)}
            onClick={() => onFAQClick(faq)}
          />
        ))}
      </div>
    </div>
  );
};
```

---

## üöÄ **Implementasyon Adƒ±mlarƒ±**

### **Phase 1: Laravel Backend Mod√ºler Intent Sistemi (2-3 g√ºn)**

#### **1.1 Core Infrastructure**
- [ ] `IntentPluginInterface` olu≈ütur
- [ ] `BaseIntentPlugin` abstract class olu≈ütur
- [ ] `IntentRegistry` sistemi kur
- [ ] `IntentResponse` model olu≈ütur
- [ ] `WidgetConfig` model olu≈ütur

#### **1.2 Plugin System**
- [ ] Plugin discovery mekanizmasƒ±
- [ ] Plugin loading/unloading sistemi
- [ ] Plugin configuration management
- [ ] Plugin validation sistemi

#### **1.3 Existing Intent Migration**
- [ ] Mevcut intent'leri plugin'lere d√∂n√º≈üt√ºr
- [ ] `product_search` ‚Üí `ProductSearchIntentPlugin`
- [ ] `faq_search` ‚Üí `FAQIntentPlugin`
- [ ] `order_tracking` ‚Üí `OrderTrackingIntentPlugin`

#### **1.4 API Updates**
- [ ] Intent registry endpoint'i (`/api/intents`)
- [ ] Plugin management endpoint'leri
- [ ] Dynamic intent handling
- [ ] Widget config endpoint'i

### **Phase 2: React Widget Mod√ºler Component Sistemi (2-3 g√ºn)**

#### **2.1 Core Infrastructure**
- [ ] `WidgetPlugin` interface olu≈ütur
- [ ] `WidgetRegistry` sistemi kur
- [ ] `DynamicWidget` component olu≈ütur
- [ ] Plugin loading/unloading mekanizmasƒ±

#### **2.2 Widget System**
- [ ] Widget configuration schema
- [ ] Widget styling system
- [ ] Widget interaction system
- [ ] Widget data mapping

#### **2.3 Existing Component Migration**
- [ ] Mevcut component'leri plugin'lere d√∂n√º≈üt√ºr
- [ ] `ProductRecommendationMessage` ‚Üí `ProductGridWidgetPlugin`
- [ ] `OrderMessage` ‚Üí `OrderTrackingWidgetPlugin`
- [ ] `CargoTrackingMessage` ‚Üí `CargoTrackingWidgetPlugin`

#### **2.4 Dynamic Loading**
- [ ] Lazy loading sistemi
- [ ] Plugin hot reload
- [ ] Error boundary'ler
- [ ] Fallback component'ler

### **Phase 3: Plugin Development Framework (1-2 g√ºn)**

#### **3.1 Plugin Template System**
- [ ] Plugin boilerplate generator
- [ ] Plugin development guide
- [ ] Plugin testing framework
- [ ] Plugin documentation

#### **3.2 Plugin Marketplace**
- [ ] Plugin repository sistemi
- [ ] Plugin versioning
- [ ] Plugin dependency management
- [ ] Plugin security validation

### **Phase 4: Advanced Features (2-3 g√ºn)**

#### **4.1 Intent Chaining**
- [ ] Multi-step intent handling
- [ ] Intent workflow system
- [ ] Context preservation
- [ ] Intent history tracking

#### **4.2 Widget Composition**
- [ ] Widget nesting sistemi
- [ ] Widget communication
- [ ] Shared state management
- [ ] Widget lifecycle hooks

#### **4.3 Performance Optimization**
- [ ] Plugin lazy loading
- [ ] Widget virtualization
- [ ] Memory management
- [ ] Caching strategies

---

## üìÅ **Dosya Yapƒ±sƒ±**

### **Laravel Backend**
```
app/
‚îú‚îÄ‚îÄ Intents/
‚îÇ   ‚îú‚îÄ‚îÄ Contracts/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ IntentPluginInterface.php
‚îÇ   ‚îú‚îÄ‚îÄ Base/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ BaseIntentPlugin.php
‚îÇ   ‚îú‚îÄ‚îÄ Plugins/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProductSearchIntentPlugin.php
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FAQIntentPlugin.php
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderTrackingIntentPlugin.php
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CampaignIntentPlugin.php
‚îÇ   ‚îú‚îÄ‚îÄ Registry/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ IntentRegistry.php
‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IntentResponse.php
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ WidgetConfig.php
‚îÇ   ‚îî‚îÄ‚îÄ Services/
‚îÇ       ‚îî‚îÄ‚îÄ IntentPluginService.php
‚îú‚îÄ‚îÄ Http/Controllers/
‚îÇ   ‚îî‚îÄ‚îÄ IntentController.php
‚îî‚îÄ‚îÄ config/
    ‚îî‚îÄ‚îÄ intents.php
```

### **React Widget**
```
widget/src/
‚îú‚îÄ‚îÄ plugins/
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProductGridWidget.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FAQAccordionWidget.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderTrackingWidget.tsx
‚îÇ   ‚îú‚îÄ‚îÄ custom/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CampaignCarouselWidget.tsx
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ registry/
‚îÇ   ‚îú‚îÄ‚îÄ WidgetRegistry.ts
‚îÇ   ‚îú‚îÄ‚îÄ PluginLoader.ts
‚îÇ   ‚îî‚îÄ‚îÄ PluginValidator.ts
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ DynamicWidget.tsx
‚îÇ   ‚îú‚îÄ‚îÄ WidgetLoader.tsx
‚îÇ   ‚îî‚îÄ‚îÄ PluginManager.tsx
‚îî‚îÄ‚îÄ types/
    ‚îú‚îÄ‚îÄ WidgetPlugin.ts
    ‚îú‚îÄ‚îÄ WidgetConfig.ts
    ‚îî‚îÄ‚îÄ PluginTypes.ts
```

---

## üîß **Konfig√ºrasyon √ñrnekleri**

### **1. Intent Plugin Configuration**
```yaml
# config/intents/plugins/product_search.yaml
name: Product Search Intent
version: 1.0.0
description: √úr√ºn arama ve √∂neri sistemi
author: ConvStateAI Team
category: product
enabled: true
permissions: ['product_read', 'search']
ai_model: 'gpt-3.5-turbo'
confidence_threshold: 0.7
widget:
  type: product_grid
  component: ProductGridWidget
  props:
    showFilters: true
    showPagination: true
    itemsPerPage: 12
  styling:
    theme: modern
    layout: grid
  interactions:
    onProductClick: track_product_click
    onFilterChange: track_filter_change
```

### **2. Widget Plugin Configuration**
```yaml
# widget/plugins/product_grid/config.yaml
id: product_grid
name: Product Grid Widget
version: 1.0.0
description: √úr√ºnleri grid layout ile g√∂steren widget
author: ConvStateAI Team
category: product
dependencies: []
required_data:
  - products
  - filters
optional_data:
  - pagination
  - sorting
styling:
  themes:
    modern:
      primary_color: '#2563EB'
      secondary_color: '#1D4ED8'
    classic:
      primary_color: '#374151'
      secondary_color: '#6B7280'
  layouts:
    grid:
      columns: 3
      gap: 16
    list:
      direction: vertical
      spacing: 12
interactions:
  events:
    - product_click
    - filter_change
    - sort_change
  analytics:
    - page_view
    - interaction_track
```

---

## üß™ **Test Stratejisi**

### **1. Unit Tests**
- [ ] Intent plugin unit tests
- [ ] Widget plugin unit tests
- [ ] Registry system tests
- [ ] Configuration validation tests

### **2. Integration Tests**
- [ ] Intent-Widget integration tests
- [ ] Plugin loading/unloading tests
- [ ] API endpoint tests
- [ ] Error handling tests

### **3. E2E Tests**
- [ ] Complete intent flow tests
- [ ] Widget rendering tests
- [ ] Plugin hot reload tests
- [ ] Performance tests

---

## üìö **Dok√ºmantasyon**

### **1. Developer Guide**
- [ ] Plugin development guide
- [ ] Widget development guide
- [ ] API documentation
- [ ] Configuration reference

### **2. User Guide**
- [ ] Plugin installation guide
- [ ] Widget configuration guide
- [ ] Troubleshooting guide
- [ ] Best practices

### **3. API Reference**
- [ ] Intent plugin API
- [ ] Widget plugin API
- [ ] Registry API
- [ ] Configuration API

---

## üéØ **Ba≈üarƒ± Kriterleri**

### **1. Mod√ºlerlik**
- ‚úÖ Yeni intent'ler kod deƒüi≈üikliƒüi yapmadan eklenebilmeli
- ‚úÖ Yeni widget'lar dinamik olarak y√ºklenebilmeli
- ‚úÖ Plugin'ler runtime'da enable/disable edilebilmeli

### **2. Geni≈ületilebilirlik**
- ‚úÖ Plugin developer'lar kolayca yeni plugin'ler geli≈ütirebilmeli
- ‚úÖ Plugin'ler birbirleriyle ileti≈üim kurabilmeli
- ‚úÖ Plugin'ler shared state kullanabilmeli

### **3. Performans**
- ‚úÖ Plugin loading < 100ms
- ‚úÖ Widget rendering < 50ms
- ‚úÖ Memory usage < 50MB per plugin
- ‚úÖ Hot reload < 200ms

### **4. G√ºvenlik**
- ‚úÖ Plugin validation ve sanitization
- ‚úÖ Permission-based access control
- ‚úÖ Sandboxed execution
- ‚úÖ Security audit logging

---

## üöÄ **Sonraki Adƒ±mlar**

### **Kƒ±sa Vadeli (1-2 hafta)**
1. Laravel backend mod√ºler intent sistemi
2. React widget mod√ºler component sistemi
3. Temel plugin framework

### **Orta Vadeli (1-2 ay)**
1. Plugin marketplace
2. Advanced intent chaining
3. Widget composition system
4. Performance optimization

### **Uzun Vadeli (3-6 ay)**
1. AI-powered intent discovery
2. Automated widget generation
3. Cross-platform plugin support
4. Enterprise plugin ecosystem

---

## üí° **√ñneriler ve Best Practices**

### **1. Plugin Development**
- Plugin'leri k√º√ß√ºk ve odaklƒ± tutun
- Dependency injection kullanƒ±n
- Error handling'i d√ºzg√ºn yapƒ±n
- Performance monitoring ekleyin

### **2. Widget Design**
- Responsive design prensiplerini uygulayƒ±n
- Accessibility standartlarƒ±nƒ± takip edin
- Consistent styling kullanƒ±n
- User experience'i √∂nceliklendirin

### **3. System Architecture**
- Loose coupling prensibini uygulayƒ±n
- Interface-based programming kullanƒ±n
- Configuration-driven development yapƒ±n
- Monitoring ve logging ekleyin

---

**Bu plan ile ConvStateAI, d√ºnyanƒ±n en mod√ºler ve geni≈ületilebilir AI chatbot sistemi haline gelecek! üéâ**
